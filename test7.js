
// let num = 60498
// let nums = []
// let i = 0
// while(num){
//   nums[i] = num%10
//   num = Math.floor( num / 10)
//   i++
// }
// let count = 0
// for(let i = 0;i<nums.length;i++){
//   if(nums[i]===0||nums[i]===6||nums[i]===9){
//     count++
//     continue
//   }
//   if(nums[i]===8){
//     count = count+2
//     continue
//   }
// }
// console.log(count);

let n = 4 
let nums = [176,170,176,176]
let names = ["beta","tom","alpha","bamma"]
let doubleArr = []
for(let i = 0;i<n;i++){
  doubleArr[i] = [nums[i],names[i]]
}
let res = []
// 先对升高排序，同时名字排序，此时相同的不用管
doubleArr.sort((a,b)=>a[0]-b[0])
// console.log(doubleArr);
// 对名字进行排序
function namessort(doubleArr,l,r){
  // 字母
  for(let i = 0;i<doubleArr[l][1].length;i++){
    // 名字
    if(i>=doubleArr[l][1].length){
      [doubleArr[l],doubleArr[temp]] = [doubleArr[temp],doubleArr[l]]
      l++
      continue
    }
    let min = doubleArr[l][1][i].charAt().charCodeAt()
    let temp = l
    let first = l
    while(first<=r){
      if(i>=doubleArr[l][1].length){
        [doubleArr[l],doubleArr[temp]] = [doubleArr[temp],doubleArr[l]]
        l++
        continue
      }
      if(doubleArr[first][1][i].charAt().charCodeAt()<min){
        min = doubleArr[first][1][i].charAt().charCodeAt()
        // 拿到最小的--index
        temp = first
      }
      first++
    }
    // 如果没有找到，就继续下一个字母
    if(temp===l) continue
    // 拿到了最小的那个名字，与第一个交换,并且第一位不进行排序
    [doubleArr[l],doubleArr[temp]] = [doubleArr[temp],doubleArr[l]]
    l++
  }

  return doubleArr
}

let j = 0
for(let i =0,j=i+1;i<n,j<n;i++){
  
  if(doubleArr[i][0]!==doubleArr[j][0]){
    continue
  }
  // 前后相等，拿到相等的起始结点
  while(j<n&&doubleArr[i][0]===doubleArr[j][0]){
    j++
  }
  doubleArr = namessort(doubleArr,i,j-1)
}
console.log(doubleArr);

// console.log('b'.charAt().charCodeAt());

// -------------------------------------------
// 你正在玩一种新型积木玩具。你可以透过玻璃看到这个玩具里面从左到右一排依次排列了若干积木。你可以从最左边塞一个积木进去，也可以从最右边拿一个积木出来——当然如果积木拿空了就不能再拿了。你想让这一列积木变成你想要的颜色序列，假如你有无限个任意颜色种类积木，你最少操作多少次可以达到呢？（每做一次塞一个积木或者取一个积木出来都算一次操作）



// 输入描述
// 我们将每种不同的颜色用了一个不同的整数来表示。

// 第一行一个正整数n，表示初始玩具中积木数量。

// 第二行n个正整数，c1[1,2,…,n]，c1[i]表示从左到右第 i 个积木的颜色。

// 第三行一个正整数m，表示你想让玩具变成的样子的积木数。

// 第四行m个正整数，c2[1,2,…m]，c2[i]表示预期中从左到右第 i 个积木的颜色。

// n,m<=1000，c1[i],c2[i]<100000000

// 数字间两两有空格隔开

// 输出描述
// 输出一行一个整数表示至少多少次操作可以达成。注意，塞只能塞到当前最左边，拿只能拿当前最右边，且你有无限多的积木。


// 样例输入
// 5
// 1 5 3 4 6
// 5
// 2 1 5 3 4
// 样例输出
// 2

// 提示
// 样例解释

// 先拿走最右边的6后，序列变成1 5 3 4

// 再塞进一个2，序列变成 2 1 5 3 4，达成。
// -----------------------------------------------
// 小团成了游戏中的营长，他打算给游戏中的士兵们排一个整齐的队。目标是让这些士兵排成整齐的一列，从左到右士兵们的身高逐渐增加，当两个士兵的身高一样的时候，就按照他们名字的字典序进行排列，因为小团觉得这样排起来最美观。

// 形式化地，给出n个士兵的身高（因为是在游戏中，身高可能很离谱）与名字（仅包含小写英文字母，并且我们保证两个不同士兵的名字不同），要将他们按照身高从小到大排序，如果身高相同则按照名字的字典序排序。

// 字典序：在英文字典中，排列单词的顺序是先按照第一个字母以升序排列（即a、b、c……z 的顺序）；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。



// 输入描述
// 第一行一个正整数n，表示士兵数

// 第二行n个空格隔开的正整数h[1,2,…n]，h[i]表示第 i 个士兵的高度。

// 第三行n个空格隔开的字符串s[1,2,…n], s[i]表示第 i 个士兵的名字，注意，士兵的名字仅包含小写英文字母且没有重复的名字。

// n<=50000，h[i]<=300 , s[i]仅包含小写英文字母且长度不大于10

// 输出描述
// 输出一行，包含n个字符串s’[1,2,…n]，s‘[i]表示经过排序后从左到右站在第i个位置的士兵的名字，不同名字间用单个空格隔开。


// 样例输入
// 4
// 176 170 176 176
// beta tom alpha bamma
// 样例输出
// tom alpha bamma beta

// 提示
// 士兵tom显然最矮，放在第一个。

// 另外的士兵身高一样，需要比较一下名字的字典序。

// alpha显然比bamma和beta小，而bamma和beta虽然第一个字母一样，但第二个字母来看显然bamma要比beta小，所以bamma在beta前面。

// -------------------------------
// 小美准备去旅行啦。旅行前小美做了充足的准备，准备好了一份将要前往旅游的城市C的地图。这份地图详尽地告诉她了城市C的所有通路。旅行过程中，小美常常忘记地图的内容而时常翻阅地图。请帮帮她吧！ 



// 输入描述
// 第一行两个正整数n和m，分别表示地图上的地点数（地点从1到n进行标号），和地图中包含的道路数。

// 接下来2行，每行m个正整数，其中第1行第 i 个数为u，其中第2行第 i 个数为v，表示地点u和地点v之间有一条直接的通路。（保证无重边，无自环）

// 接下来一个正整数q，表示小美想询问的次数。

// 接下来q行，每行两个正整数u和v，表示一次询问：地点u和地点v之间是否有一条直接的通路呢？

// (题中道路为双向路，数字间两两有空格隔开)

// n<=10000, m<=10000, q<=300

// 1<=u<=n, 1<=v<=n, u≠v

// 输出描述
// 输出q行，每行分别对应一次询问的回答。

// 每行输出Yes或者No表示存在或者不存在一条直接的道路。


// 样例输入
// 4 5
// 1 2 1 3 1
// 2 1 3 2 4
// 4
// 1 2
// 2 4
// 2 3
// 1 4
// 样例输出
// Yes
// No
// Yes
// Yes

// 提示
// 第一个询问，题目中第一条道路1 2即满足条件

// 第二个询问，题目中没有哪条道路直接连接2和4

// 第三个询问，题目中第四条道路3 2直接连接了地点2和地点3，满足了要求

// 第四个询问，题目中第五条道路1 4即满足条件
// -----------------------------------
// 时间限制： 3000MS
// 内存限制： 589824KB
// 题目描述：
// 以防大家不知道，井字棋的棋盘是一个3×3的小棋盘，如下图所示：



// 但是小团玩腻了井字棋，想出了一个新玩法，小团把井字棋的棋盘改成了2×2的小棋盘。



// 小团给每个格子选择一种颜色，并达到以下要求：①任何一行有两种不同颜色，②任何一列有两种不同颜色。也即任何一行或一列中没有重复颜色。现在小团想知道他能以多少种不同的方案达成上述要求。两种方案不同当且仅当至少存在一个位置，两个方案在该位置有着不同的颜色。



// 输入描述
// 给出小团拥有的颜色总数n，每一种颜色都是无限使用的。另外小团也不能调和颜色。

// n<=10